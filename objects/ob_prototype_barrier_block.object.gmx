<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sp_prototype_barrier_block</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Set up the fixture for the block

fix = physics_fixture_create();

bezel = 0;
if(bezel == 0)
{
  // Build the fixture point by point, but as a rectangle.
  physics_fixture_set_polygon_shape(fix);
  physics_fixture_add_point(fix, 0, 0);
  physics_fixture_add_point(fix, sprite_width, 0);
  physics_fixture_add_point(fix, sprite_width, sprite_height);
  physics_fixture_add_point(fix, 0, sprite_height);
}
else
{
  // Build the fixture point by point, but with a bevel.
  // It will end up looking like this:
  //
  //    / - \
  //    |   |       vs. a normal rectangle
  //    \ - /
  //
  physics_fixture_set_polygon_shape(fix);
  physics_fixture_add_point(fix, 0, bevel);
  physics_fixture_add_point(fix, bevel, 0);
  physics_fixture_add_point(fix, sprite_width - bevel, 0);
  physics_fixture_add_point(fix, sprite_width, bevel);
  physics_fixture_add_point(fix, sprite_width, sprite_height - bevel);
  physics_fixture_add_point(fix, sprite_width - bevel, sprite_height);
  physics_fixture_add_point(fix, bevel, sprite_height);
  physics_fixture_add_point(fix, 0, sprite_height - bevel);
}

// Set the physics properties of the fixture
physics_fixture_set_density(fix, barrier_block_density);
physics_fixture_set_collision_group(fix, barrier_block_collision_group);
physics_fixture_set_friction(fix, barrier_block_friction);
physics_fixture_set_linear_damping(fix, barrier_block_linear_dampening);
physics_fixture_set_angular_damping(fix, barrier_block_angular_dampening);
physics_fixture_set_restitution(fix, barrier_block_restitution);

// Bind the darn fixture
physics_fixture_bind(fix, id);

// Game logic properties
player_was_touching_me_inappropriately = false;
collision_x[0] = 0;
collision_x[1] = 0;
collision_y[0] = 0;
collision_y[1] = 0;
touch_direction_blocks_perspective = "null";
touch_direction_players_perspective = "null";

// Set nroms to which the teleporter can anchor.
norms[0, 0] = 1;
norms[0, 1] = 0;

norms[1, 0] = -1;
norms[1, 1] = 0;

norms[2, 0] = 0;
norms[2, 1] = 1;

norms[3, 0] = 0;
norms[3, 1] = -1;

// Debug
if (debug_player_collisions == true)
{
  // Turn messages on
  debug_player_collision_send_message = true;

  // Get random color for contact flares  
  randomize();
  barrier_block_color_code_debug = floor(random(18.9999)) + 1;

  switch(barrier_block_color_code_debug)
  {
    case 1: 
    {
      collision_debug_color = c_aqua;
      break;
    };
    case 2: 
    {
      collision_debug_color = c_black;
      break;
    };
    case 3: 
    {
      collision_debug_color = c_blue;
      break;
    };
    case 4:
    {
      collision_debug_color = c_dkgray;
      break;
    };
    case 5: 
    {
      collision_debug_color = c_fuchsia;
      break;
    };
    case 6: 
    {
      collision_debug_color = c_gray;
      break;
    };
    case 7: 
    {
      collision_debug_color = c_green;
      break;
    };
    case 8: 
    {
      collision_debug_color = c_lime;
      break;
    };
    case 9: 
    {
      collision_debug_color = c_ltgray;
      break;
    };
    case 10: 
    {
      collision_debug_color = c_maroon;
      break;
    };
    case 11: 
    {
      collision_debug_color = c_navy;
      break;
    };
    case 12: 
    {
      collision_debug_color = c_olive;
      break;
    };
    case 13: 
    {
      collision_debug_color = c_orange;
      break;
    };
    case 14: 
    {
      collision_debug_color = c_purple;
      break;
    };
    case 15: 
    {
      collision_debug_color = c_red;
      break;
    };
    case 16: 
    {
      collision_debug_color = c_silver;
      break;
    };
    case 17: 
    {
      collision_debug_color = c_teal;
      break;
    };
    case 18: 
    {
      collision_debug_color = c_yellow;
      break;
    };
    case 19: 
    {
      collision_debug_color = c_yellow;
      break;
    };
  };
};
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (player_was_touching_me_inappropriately == true)
{
/*  if (!physics_test_overlap(collision_x[0], collision_y[0], 0, player_id) 
   &amp;&amp; !physics_test_overlap(collision_x[1], collision_y[1], 0, player_id)) */
  if (!physics_test_overlap(phy_position_x, phy_position_y, 0, player_id))
  {
    player_was_touching_me_inappropriately = false;
    player_on_top_of_barrier_block = false;
    touch_direction_blocks_perspective = "null";
    touch_direction_players_perspective = "null";
    
    // Debug
    if (debug_player_collisions == true)
    {
      debug_player_collision_send_message = true;
      sprite_index = sp_prototype_barrier_block;
    }
  }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="ob_prototype_green_teleporter_thrown">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>teleporter_will_grip = 0;

for (i = 0; i &lt;= 3; i++)
{
  if ((norms[i, 0] == phy_col_normal_x) &amp;&amp; (norms[i, 1] == phy_col_normal_y))
  {
    teleporter_will_grip = 1;
  };
};

if (teleporter_will_grip == 1)
{
  instance_create(phy_collision_x, phy_collision_y, ob_prototype_green_teleporter_active);
};
else
{
  instance_create(phy_position_x, phy_position_y, ob_prototype_green_teleporter_inert);  
};
with (ob_prototype_green_teleporter_thrown)
{
  instance_destroy();
};
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="ob_prototype_player">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Set variable to tell the step event in this instance that the block has been touched, and needs to respond to being departed from
player_was_touching_me_inappropriately = true;

// Check to find the direction of the collision
if (phy_collision_points == 2)
{
  // Store the collision locations so that the step event in this instance can access the data.
  collision_x[0] = phy_collision_x[0];
  collision_x[1] = phy_collision_x[1];
  collision_y[0] = phy_collision_y[0];
  collision_y[1] = phy_collision_y[1];
   
  // Check to see the direction of contact from the block's perspective
  if (phy_collision_y[0] &lt;= phy_position_y + (sprite_height / 2) &amp;&amp; phy_collision_y[1] &lt;= phy_position_y + (sprite_height / 2)
      &amp;&amp; abs(phy_collision_y[0] - phy_collision_y[1]) &lt;= barrier_block_collision_check_threshold)
  {
    touch_direction_blocks_perspective = "top";    
  };
  if (phy_collision_y[0] &gt;= phy_position_y + (sprite_height / 2) &amp;&amp; phy_collision_y[1] &gt;= phy_position_y + (sprite_height / 2)
      &amp;&amp; abs(phy_collision_y[0] - phy_collision_y[1]) &lt;= barrier_block_collision_check_threshold)
  {
    touch_direction_blocks_perspective = "bottom";
  };
  if (phy_collision_x[0] &lt;= phy_position_x + (sprite_width / 2) &amp;&amp; phy_collision_x[1] &lt;= phy_position_x + (sprite_width / 2)
      &amp;&amp; abs(phy_collision_x[0] - phy_collision_x[1]) &lt;= barrier_block_collision_check_threshold)
  {
    touch_direction_blocks_perspective = "right";
  };
  if (phy_collision_x[0] &gt;= phy_position_x + (sprite_width / 2) &amp;&amp; phy_collision_x[1] &gt;= phy_position_x + (sprite_width / 2)
      &amp;&amp; abs(phy_collision_x[0] - phy_collision_x[1]) &lt;= barrier_block_collision_check_threshold)
  {
    touch_direction_blocks_perspective = "left";
  };

  // Check to see the direction of contact from the player's perspective
  with (ob_prototype_player)
  {
    if (phy_collision_y[0] &lt;= phy_position_y + (sprite_height / 2) &amp;&amp; phy_collision_y[1] &lt;= phy_position_y + (sprite_height / 2)
        &amp;&amp; abs(phy_collision_y[0] - phy_collision_y[1]) &lt;= barrier_block_collision_check_threshold)
    {
      other.touch_direction_players_perspective = "top";    
    };
    if (phy_collision_y[0] &gt;= phy_position_y + (sprite_height / 2) &amp;&amp; phy_collision_y[1] &gt;= phy_position_y + (sprite_height / 2)
        &amp;&amp; abs(phy_collision_y[0] - phy_collision_y[1]) &lt;= barrier_block_collision_check_threshold)
    {
      other.touch_direction_players_perspective = "bottom";
    };
    if (phy_collision_x[0] &lt;= phy_position_x + (sprite_width / 2) &amp;&amp; phy_collision_x[1] &lt;= phy_position_x + (sprite_width / 2)
        &amp;&amp; abs(phy_collision_x[0] - phy_collision_x[1]) &lt;= barrier_block_collision_check_threshold)
    {
      other.touch_direction_players_perspective = "right";
    };
    if (phy_collision_x[0] &gt;= phy_position_x + (sprite_width / 2) &amp;&amp; phy_collision_x[1] &gt;= phy_position_x + (sprite_width / 2)
        &amp;&amp; abs(phy_collision_x[0] - phy_collision_x[1]) &lt;= barrier_block_collision_check_threshold)
    {
      other.touch_direction_players_perspective = "left";
    }; 
  };
  
  switch (touch_direction_blocks_perspective)
  {
    case "top":
    {
      
      switch (touch_direction_players_perspective)
      {
        case "top":
        {
          show_debug_message("Collision problem: register touch at top of block and top of player." + "bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective);
          break;
        };
        case "bottom":
        {
          player_on_top_of_barrier_block = true;
          player_bumping_barrier_block_side = "null";
          player_headbutting_barrier_block = false;
          
          // Debug
          if (debug_player_collisions == true)
          {
            if (debug_player_collision_send_message == true)
            {
              debug_player_collision_send_message = false;
              show_debug_message("bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective + "   Landed!");
            };
          };

          break;
        };
        case "left":
        {
          show_debug_message("Collision problem: register touch at top of block and left of player." + "bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective);
          break;
        };
        case "right":
        {
          show_debug_message("Collision problem: register touch at top of block and right of player." + "bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective);
          break;
        };
      };
      break;
    };
    case "bottom":
    {
      switch (touch_direction_players_perspective)
      {
        case "top":
        {
          player_on_top_of_barrier_block = false;
          player_bumping_barrier_block_side = "null";
          player_headbutting_barrier_block = true;

          // Debug
          if (debug_player_collisions == true)
          {
            if (debug_player_collision_send_message == true)
            {
              debug_player_collision_send_message = false;
              show_debug_message("bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective + "   Bumpmed!");
            };
          };

          break;
        };
        case "bottom":
        {
          show_debug_message("Collision problem: register touch at bottom of block and bottom of player." + "bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective);
          break;
        };
        case "left":
        {
          show_debug_message("Collision problem: register touch at bottom of block and left of player." +"bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective);
          break;
        };
        case "right":
        {
          show_debug_message("Collision problem: register touch at bottom of block and right of player." + "bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective);
          break;
        };
      };
      break;
    };
    case "left":
    {
      switch (touch_direction_players_perspective)
      {
        case "top":
        {
          show_debug_message("Collision problem: register touch at left of block and top of player." + "bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective);
          break;
        };
        case "bottom":
        {
          show_debug_message("Collision problem: register touch at left of block and bottom of player." + "bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective);
          break;
        };
        case "left":
        {
          show_debug_message("Collision problem: register touch at left of block and left of player." + "bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective);
          break;
        };
        case "right":
        {
          player_on_top_of_barrier_block = false;
          player_bumping_barrier_block_side = "left";
          player_headbutting_barrier_block = false;

          // Debug
          if (debug_player_collisions == true)
          {
            if (debug_player_collision_send_message == true)
            {
              debug_player_collision_send_message = false;
              show_debug_message("bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective + "   Left!");
            };
          };

          break;
        };
      };
      break;
    };
    case "right":
    {
      switch (touch_direction_players_perspective)
      {
        case "top":
        {
          show_debug_message("Collision problem: register touch at right of block and top of player." + "bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective);
          break;
        };
        case "bottom":
        {
          show_debug_message("Collision problem: register touch at right of block and bottom of player." + "bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective);
          break;
        };
        case "left":
        {
          player_on_top_of_barrier_block = false;
          player_bumping_barrier_block_side = "right";
          player_headbutting_barrier_block = false;

          // Debug
          if (debug_player_collisions == true)
          {
            if (debug_player_collision_send_message == true)
            {
              debug_player_collision_send_message = false;
              show_debug_message("bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective + "   Right!");
            };
          };

          break;
        };
        case "right":
        {
          show_debug_message("Collision problem: register touch at right of block and right of player." + "bb: " + touch_direction_blocks_perspective + "    p: " + touch_direction_players_perspective);
          break;
        };
      };
      break;
    };
  };
  
  // Debug stuff
  // Change the block to "glowy block"
  if (debug_player_collisions == true)
  {
    sprite_index = sp_prototype_barrier_block_touching;
  };
  
  // Show the collision visibly. This is commented out unless strictly needed; it's not that pretty. :)
  /*
  if (debug_player_collisions == true)
  {
    effect_create_above(ef_flare, phy_collision_x[0], phy_collision_y[0], 0.1, collision_debug_color);
    effect_create_above(ef_flare, phy_collision_x[1], phy_collision_y[1], 0.1, collision_debug_color);
    effect_create_above(ef_ellipse, phy_position_x, phy_position_y, 0.001, collision_debug_color);
    effect_create_above(ef_explosion, phy_position_x + (sprite_width / 2), phy_position_y + (sprite_height / 2), 0.001, collision_debug_color);
  }
  */
};
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>1</PhysicsObjectShape>
  <PhysicsObjectDensity>0</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>1</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>-1</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>32,0</point>
    <point>32,32</point>
    <point>0,32</point>
  </PhysicsShapePoints>
</object>
